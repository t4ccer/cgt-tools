use super::common::DomineeringResult;
use anyhow::{Context, Result};
use cgt::{
    grid::{FiniteGrid, small_bit_grid::SmallBitGrid},
    numeric::rational::Rational,
    short::partizan::games::domineering::{self, Domineering},
};
use clap::Parser;
use std::{
    collections::HashSet,
    fs::File,
    io::{BufReader, BufWriter, Read, Write, stdin, stdout},
    num::NonZeroU32,
    str::FromStr,
};

#[derive(Debug, Clone)]
struct DomineeringEntry {
    temperature: Rational,
    grid: domineering::Domineering,
}

impl DomineeringEntry {
    fn new(result: &DomineeringResult) -> Result<Self> {
        Ok(DomineeringEntry {
            temperature: Rational::from_str(&result.temperature)
                .ok()
                .context("Invalid temperature")?,
            grid: domineering::Domineering::from_str(&result.grid)
                .ok()
                .context("Invalid grid")?,
        })
    }
}

/// Convert search report (sequence of JSON objects) to LaTeX table
#[derive(Parser, Debug)]
pub struct Args {
    /// Input newline-separated JSON file, usually obtained by running `search` command. Use '-' for stdin
    #[arg(long)]
    in_file: String,

    /// Output LaTeX file with generated table. Use '-' for stdout
    #[arg(long, default_value = "-")]
    out_file: String,

    /// Number of columns in LaTeX file
    #[arg(long, default_value_t = NonZeroU32::new(3).unwrap())]
    columns: NonZeroU32,

    /// Position scale, ie. scaling factor of tile size. 1 => 1cm.
    #[arg(long, default_value_t = 0.4)]
    position_scale: f32,

    /// Include positions that are rotations of already included positions
    #[arg(long, default_value_t = false)]
    include_rotations: bool,
}

#[allow(clippy::needless_pass_by_value)]
pub fn run(args: Args) -> Result<()> {
    let input: BufReader<Box<dyn Read>> = if args.in_file == "-" {
        BufReader::new(Box::new(stdin()))
    } else {
        BufReader::new(Box::new(
            File::open(&args.in_file)
                .context(format!("Could not open input file '{}'", args.in_file))?,
        ))
    };

    let mut output: BufWriter<Box<dyn Write>> = if args.out_file == "-" {
        BufWriter::new(Box::new(stdout()))
    } else {
        BufWriter::new(Box::new(File::create(&args.out_file).context(format!(
            "Could not create/open output file '{}'",
            args.out_file
        ))?))
    };

    let input = serde_json::de::Deserializer::from_reader(input)
        .into_iter::<DomineeringResult>()
        .map(|line| {
            line.map_err(anyhow::Error::new)
                .context("Could not parse JSON")
                .and_then(|r| DomineeringEntry::new(&r))
        })
        .collect::<Result<Vec<_>, _>>()?;

    // remove rotations
    let mut input = if args.include_rotations {
        input
    } else {
        let mut seen = HashSet::new();
        input
            .iter()
            .filter_map(|entry| {
                let grid = *entry.grid.grid();
                let rotated = |grid: SmallBitGrid<domineering::Tile>| {
                    [
                        grid,
                        grid.rotate(),
                        grid.rotate().rotate(),
                        grid.rotate().rotate().rotate(),
                    ]
                };
                let equivalent_grids = [
                    rotated(grid),
                    rotated(grid.vertical_flip()),
                    rotated(grid.horizontal_flip()),
                    rotated(grid.vertical_flip().horizontal_flip()),
                ];
                let representative = equivalent_grids
                    .as_flattened()
                    .iter()
                    .max_by_key(|grid| (grid.width, grid.grid))
                    .copied()
                    .unwrap();

                seen.insert(representative).then_some(DomineeringEntry {
                    grid: Domineering::new(representative),
                    ..*entry
                })
            })
            .collect::<Vec<_>>()
    };

    input.sort_by(|lhs, rhs| rhs.temperature.cmp(&lhs.temperature)); // descending sort

    let max_grid_width = input
        .iter()
        .map(|entry| entry.grid.grid().width())
        .max()
        .unwrap_or(0);

    let mut input = input.into_iter().peekable();

    let pos_width = format!("{}cm", args.position_scale * (max_grid_width as f32));

    // define table
    writeln!(output, "{{")?;
    writeln!(output, "%% Auto generated by `cgt-cli`")?;
    writeln!(output, "%% Make sure to include preamble from README.md")?;
    write!(
        output,
        "\\begin{{longtable}}{{@{{\\extracolsep{{\\fill}}}}m{{{pos_width}}} m{{1cm}}"
    )?;
    for _ in 1..args.columns.get() {
        write!(output, "|m{{{pos_width}}} m{{1cm}}")?;
    }
    write!(output, "@{{}}}} \n\\hline ")?;

    // header
    for idx in 0..args.columns.get() {
        if idx != 0 {
            write!(output, "& ")?;
        }
        write!(output, "Position & Temp. ")?;
    }
    writeln!(output, "\\\\ \\hline \\endhead")?;

    // entries
    while input.peek().is_some() {
        for idx in 0..args.columns.get() {
            if let Some(entry) = input.next() {
                if idx != 0 {
                    write!(output, "& ")?;
                }
                writeln!(
                    output,
                    "{} & ${}$ ",
                    entry.grid.to_latex_with_config(domineering::LatexConfig {
                        scale: args.position_scale,
                        vertical_marigin: Some(1.5),
                        baseline: Some(0.0)
                    }),
                    entry.temperature
                )?;
            }
        }
        writeln!(output, "\\\\")?;
    }

    writeln!(output, "\\end{{longtable}}")?;
    writeln!(output, "}}")?;
    Ok(())
}
